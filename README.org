#+title: You and me, zyre. üç†

* Problem statement

The problem is to answer these questions in a satisfactory way:

- How can an instance of my application know about other instances and
  vice versa?

- How can my application know about the addresses of sockets provided
  by other applications and vice versa?

- How can my application select among those sockets to find a subset
  of interest?

- How can these interesting sockets be identified in a way that is
  semantically meaningful to my application code?

- How can my multi-threaded application use sockets safely?

- How can my application use abstract plugins which may not "know"
  about my application but also wants to use sockets in these ways?

- How do I do this in C++, but maybe also in other languages?

* yamz Solution

yamz answers these questions in a hopefully satisfying way.  

First, it uses the Zyre (ZRE) discovery mechanism to allow peers on
the network to learn information about each other.  yamz uses Zyre
publish information the application's sockets which ~bind()~ and from
this information published by others it can learn which addresses the
application sockets may ~connect()~.

ZeroMQ (non-draft) sockets are only thread-safe when kept to a single
thread.  yamz thus orchestrates this discovery protocol in a way that
allows sockets to be created in the threads that will use them.  This
means socket creation can still be distributed throughout application
components, and even abstract plugins, while presenting to the
discovery network information as if it was from a single entity.

Socket construction and their ~bind()~ and ~connect()~ becomes very
uniform which minimizes the API to which application components must
learn.  yamz takes this even further to allow the application
components to have zero-configuration sockets.  yamz can receive its
configuration directly and application developers need only agree on
names for their sockets.  In cases where more fine-grained
configuration control is required, yamz provides methods for it.

In order to supply all this, yamz sets up a tiny *intra-application*
network.  Nominally this network is based on ZeroMQ ~inproc~ transport
so that traffic remains in memory of the application.  Being based on
ZeroMQ it is possible to instead or in addition use other transports.

At the center of this network is the yamz server which mediates
between Zyre and a number of clients.  Each distinct application
component which needs one or more sockets may uses a simple yamz
client API to simple get them, ready-to-use.  As the network involves
asynchronous message passing while typical application code prefers to
work with synchronous APIs, both the server and client are provided
with an outward synchronous facade to an asynchronous backend.


* Client API walkthrough


* Server API walkthrough

* Socket Addressing

yamz uses URIs to identify sockets.

** Address Categories

Depending on the form and intent of the information provided by a URI,
it is interpreted as being in one of three categories.

- Concrete :: Any fully-qualified address in one of the supported
  ZeroMQ URI schemes (~tcp~, ~ipc~ and ~inproc~).  It is fully-qualified in
  that it contains no wildcard character.  A *concrete* address may be
  given for either a ~bind()~ or a ~connect()~.

- Ephemeral :: Any address given in one of the supported ZeroMQ URI
  schemes which has at least one wildcard character ("~*~").  An
  *ephemeral* address may only be given for a ~bind()~.  In the process of
  performing a ~bind()~ with an ephermal address, yamz will construct a
  corresponding *concrete* address.  Note, a concrete address may be
  used in place of an ephemeral one.

- Abstract :: An address given with a URI scheme of ~yamz~.  It may be
  resolved into zero or more concrete addresses through the yamz
  discovery process.  An *abstract* address may only be given for the
  intention of applying a ~connect()~ to all resolved concrete
  addresses.  

All address categories URIs may have a *query* part which is described below.

** ~yamz://~ URI scheme

As above, the ~yamz~ URI scheme is only meaningful for specifying
abstract addresses.  They are resolved to a set of concrete addresses
by yamz and to each a ~connect()~ will be applied.  

The ~yamz~ URI (omitting the *query* part) is generally:

#+begin_example
yamz://[node]/[path]
#+end_example

The parts are interpreted as:

- node :: the name for a zyre peer, required but wildcard allowed,

- path :: a /-separated path locating a node's socket, required but elements may be provided by wildcards.

The ~yamz~ scheme allows the *nade* and elements of the *path* to be
specified with the wildcard character ("~*~").  Some examples:

- ~yamz://*/log~ would match all sockets named "log" for all nodes
- ~yamz://friend/*/out~ would match all sockets named "out" in all components of node "friend"
- ~yamz://friend/fanout/*~ would match all sockets from component "fanout" of node "friend".

Note, the wildcard does not match element separators but maybe one day
we support ant glob.  See next for other ways to match.

** Query parameters

For a *concrete* or *ephemeral* ~bind()~ address, the query part specifies a
set of key/value attributes to associate with the address in yamz
discovery.

For an *abstract* ~connect()~ address, the query part specifies /matches/
(regular expressions) to apply against key/value attributes in yamz
discovery.  

For example, a ~bind()~ address for a socket that provides a source of
"TPC trigger primitive" objects which derive from some portion of a
larger data source (part, det, apa, face) may be specified like:

#+begin_example
tcp://*:*?part=2&det=tpc&role=tpsource&apa=42&face=1
#+end_example

Another socket may wish to connect to a subset of all such sockets
over all faces of multiple APAs and might do so by specifying an
abstract address like:

#+begin_example
yamz://*/tps?part=2&det=tpc&apa=4[12]
#+end_example

Where, in this invented world, the socket name ~tps~ implies the role
~tpsource~.  Note, the ~yamz::Server~ may be given a collection of
"expected" peer nodes.  If so, the wildcard for the node ~yamz://*~ will
match within this subset.

* Discovery

yamz discovery is based on Zyre which implements the concept of a
fully connected graph.  Every node added to the graph knows about
every other node.  An instance of ~yamz::Server~ is associated with
one node and makes known some of the information it has collected from
the instances of ~yamz::Client~ requests it has received.  From the
information published by other nodes, the ~yamz::Server~ will attempt
to satisfy the outstanding client requests.

An application can make a number of ~yamz::Server~ instances.
However, it is typically sufficient for one process to have but one as
a single yamz node can take care of complex internal structure.  For
example the application may have yamz clients distributed through
"components", "modules", "plugins", etc.

The application developer need not understand the details of yamz
discovery and instead focus on the simple ~yamz::Server~ and/or
~yamz::Client~ class API.  The details that follow will be important
for any compatible implementation of yamz that does not use ~libyamz~.

** ~YAMZ~ Header

yamz publishes in the Zyre ENTER event a header named ~YAMZ~.  The
value of this header is a JSON encoded string.  Loading the JSON
results in a tree structure that maps to the application structure as
reported by the yamz client requests.

Every vertex of this tree is an object following ~yamz::TreeVtx~ schema
and having attributes:

- name :: (required) a simple string identifier unique to all sibling vertices
- port :: (optional) a description of a bind socket of type ~yamz::TreePort~
- params :: (optiona) zero or more key/value pairs, each as free-form strings, each of type ~yamz::TreeParam~
- children :: (optional) sequence of zero or more child vertices

Parameters may be provided directly to the ~yamz::Server~ instance or
through client requests.  Parameters are taken to assert information
about the vertex's *port* (if it exists) and to any children vertices.
A parameter in a child vertex is taken to override any of the same
name found in ancestor vertices.

** Other yamz headers

yamz may define additional headers and reserves them to begin with a
~YAMZ~ prefix.

